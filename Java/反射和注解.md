### **反射机制**

反射 reflect

- 类是用来描述一组对象反射机制认为是描述一组类
- Class        用来描述类本身
- Field         用来描述类中的属性
- Method    用来描述类中的构造方法 
- Constructor      用来描述类中的构造方法
- Annotation       用来描述类中的注解@Override
- Package          用来描述类所属的包

1. 如何获取Class

   - 如下三种方式

     1. `Class c = Class.forName("包名.类名");`
     2. `Class c = 类名.class;`
     3. `对象的引用.getClass();`    //Object类中的方法

   - Class中常用方法

     `getModifiers();` //获取类的特征修饰符（权限，特征）

     `getName();  `//类名

     `getSimpleName(); ` //包名+类名

     `Package p = getPackage();`

     `getSuperClass();`  //获取超类（父类）

     `getInterfaces();`  //获取所有父接口

     `Object obj = newInstance();`  //默认调用无参数构造方法创建对象

     ```java
     package testreflect;
     
     import java.util.ArrayList;
     
     public class TestMain {
         public static void main(String[] args) {
             /*
             //通过Class对象来操作Person.class类
             try {
                 Class c = Class.forName("testreflect.Person");
                 //类有自己的结构
                 int modifiers = c.getModifiers();
                 //每一个修饰符，用一个整数类进行表示
                 //0--默认不写   1--public 2--private   4--protected
                 //8--static    16--final  32--synchorioned  64--volatile
                 //1024--abstract
     
                 //类的名字
                 String name = c.getName();  //类名
                 String simpleName = c.getSimpleName();  //包名+类名
                 //获取类所在的包
                 Package pkg = c.getPackage();
                 String pkgName = pkg.getName();
                 //获取父类
                 Class sc = c.getSuperclass();
     
     
             } catch (ClassNotFoundException e) {
                 e.printStackTrace();
             }
             */
     
             //获取ArrayList的所有父类
             ArrayList<String> arrayList = new ArrayList<>();
             Class c = ArrayList.class;
             Class sc = c.getSuperclass();
             while (sc!=null){
                 System.out.println(sc.getName());
                 sc = sc.getSuperclass();
             }
     
             //获取当前c的所有父亲接口
             Class[] classes = c.getInterfaces();
             for (Class c1:classes){
                 System.out.println(c.getName());
             }
             
         }
     }
     
     ```

     `Field field = getField()`

2. 获取Field

   - Field类中常用方法

     `getModifiers();`

     `getType();`

     `getName();`

     操作属性，向里面存值

     `set(对象,值)`

     操作属性，向里面取值

     `get(对象,值)`      如上两个方法只能获取公有的属性，但是包含继承的

     `getDeclaredField();`  获取私有属性

     ```java
     package testreflect;
     
     import java.lang.reflect.Field;
     import java.util.ArrayList;
     
     public class TestMain {
         public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
             try {
                 Class clazz = Class.forName("testreflect.Person");
                 Field[] fields = clazz.getFields();
                 Person p = (Person)clazz.newInstance();
                 Field f = clazz.getDeclaredField("age");  //私有属性
                 f.setAccessible(true);
                 f.set(p,19);
                 String value = (String) f.get(p);
     
     
                 Field nameField = clazz.getField("name"); //知道属性的名字，并且属性是公有
     
                 int modifiers = nameField.getModifiers();  //属性修饰符
                 Class fclass = nameField.getType(); //获取属性的类型
                 String fname = nameField.getName(); //获取属性名
                 //操作属性
                 //nameField.set(new Person(),"Martin");
                 nameField.set(p,"Martin");
                 String name = (String)nameField.get(p);
     
     
             } catch (ClassNotFoundException | InstantiationException e) {
                 e.printStackTrace();
             }
     
         }
     }
     
     ```

   - 修改String字符串中的内容（String不可变特性）

     ```java
     package testreflect;
     
     import java.lang.reflect.Field;
     
     public class ChangeStringValue {
         public static void main(String[] args) {
             try {
                 String str = new String("abc");
                 //可以通过反射改变String的不可变特性
                 Class clazz = str.getClass();
                 Field f = clazz.getDeclaredField("value");
                 f.setAccessible(true);
                 //获取属性值
                 char[] temp = (char[])f.get(str);
                 temp[0]='j';temp[1]='p';temp[2]='8';
     
             } catch (NoSuchFieldException e) {
                 e.printStackTrace();
             } catch (IllegalAccessException e) {
                 e.printStackTrace();
             }
         }
     }
     ```

     

3. 