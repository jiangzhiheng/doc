一、网络虚拟化基础：`namespace`

1. `Linux`的`namespace`：

   - 作用：隔离内核资源
   - 种类：
     - `Mount namespace`：文件系统挂载点
     - `UTS namespace`：主机名
     - `IPC namespace`：`POSIX`进程间通信消息队列
     - `PID namespace`：进程`PID`数字空间
     - `network namespace`：`IP`地址
     - `user namespace`：`user ID`
   - 特点：`Linux`的`namespace`给里面的进程造成了两个错觉：
     - 它是系统里唯一的进程
     - 它独享系统的所有资源
   - 默认情况下，`Linux`进程处在和宿主机相同的`namespace`,即初始的根`namespace`里，默认享有全局系统资源

2. `network namespace`

   - 作用：隔离`Linux`系统的设备，以及`IP`地址、端口、路由表、防火墙规则等资源，因此每个网络`namespace`中都有自己的网络设备（如`IP`地址、路由表，端口范围、`/proc/net`目录等）

3. `network namespace`的创建

   - 通过`Linux`的`ip`工具的`netns`子命令

     ```shell
     [root@docker01 ~]# ip netns help
     Usage: ip netns list
            ip netns add NAME
            ip netns set NAME NETNSID
            ip [-all] netns delete [NAME]
            ip netns identify [PID]
            ip netns pids NAME
            ip [-all] netns exec [NAME] cmd ...
            ip netns monitor
            ip netns list-id
     ```

     ```shell
     # 创建一个network namespace
     ip netns add netns1
     # 查看系统有哪些network namespace
     ip netns list
     # 进入namespace执行操作
     ip netns exec netns1 ip link list
     # 删除创建network namespace
     ip netns delete netns1
     
     # 当ip命令创建了一个network namespace时，系统会在/var/run/netns路径下自动生成一个挂载点，挂载点的作用一方面是对namespace的管理，另一方面是使namespace没有进程运行也能存在
     ```

4. 配置`network namespace`

   1. 启用`lo`接口，默认`down`

      ```shell
      # ip netns exec netns1 ip link set dev lo up
      # ip netns exec netns1 ping 127.0.0.1 
      PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
      64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.039 ms
      ```

   2. 创建`veth pair`

      ```shell
      # 创建veth pair
      ip link add veth0 type veth peer name veth1
      # 将veth1放到netns1 namespace中
      ip link set veth1 netns netns1
      
      [root@docker01 ~]# ip netns exec netns1 ip link list
      1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
          link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      5: veth1@if6: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
          link/ether fe:ce:e7:4b:9f:a3 brd ff:ff:ff:ff:ff:ff link-netnsid 0
      ```

   3. 配置`veth pair`

      ```shell
      # 给netns1中的veth1设置ip地址并up
      ip netns exec netns1 ifconfig veth1 10.1.1.1/24 up
      # 给veth pair的另一半(位于宿主机)设置ip地址
      ifconfig veth0 10.1.1.2/24 up
      ```

   4. 双向测试

      ```shell
      [root@docker01 ~]# ping 10.1.1.1
      64 bytes from 10.1.1.1: icmp_seq=2 ttl=64 time=0.094 ms
      [root@docker01 ~]# ip netns exec netns1 ping 10.1.1.2
      64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.201 ms
      ```

   5. 另外，不同`network namespace`之间的路由表和防火墙等也是隔离的

   6. `Tips`

      - 进程可以通过`Linux`系统调用`clone(),unshare()和setns`进入`network namespace`

      - 非`root`进程被分配到`network namespace`后只能访问和配置已经存在于该`network`的设备

      - `root`进程可以在`network namespace`里创建新的网络设备

      - `network namespace`里的`root`进程还能把本`network namespace`的虚拟网络设备分配到其它`network namespace`,这个路径可以从主机的根`network namespace`到用户自定义的`namespace`,反之亦可

      - 请看以下命令

        ```shell
        ip netns exec netns1 ip link set veth1 1
        
        # 以上命令的作用是进入netns1，将veth1 移动到PID为1(init进程)所在的network namespace
        # 所以这会造成一定的安全风险，对namespace的root用户而言，它们都可以把namespace里的虚拟网络设备移动到其它network namespace中，甚至包括主机根network namespace！！，如果需要屏蔽这一行为，则需要结合PID namespace和Mount namespace
        ```

5. `network namespace API`的使用

   `clone(),unshare(),和setns()`系统调用会使用`CLONE_NEW*`来区别要操作的`namespace`类型，`CLONE_NEW*`常量一共有6个，分别是`CLONE_NEWIPC,CLONE_NEWNS,CLONE_NEWNET,CLONE_NEWPID,CLONE_NEWUSER,CLONE_NEWUTS`

   1. 创建`namespace`：`clone`系统调用

   2. `/proc/PID/ns`目录：维持`namespace`存在

      - 每个`Linux`进程都拥有一个属于自己的`/proc/PID/ns`,这个目录下的每一个文件都代表了一个类型的`namespace`,这些文件提供了操作进程关联`namespace`的一种方式

        ```shell
        [root@docker01 ~]# ll /proc/1/ns/
        total 0
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 ipc -> ipc:[4026531839]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 mnt -> mnt:[4026531840]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 net -> net:[4026531956] # 代表network namespace
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 pid -> pid:[4026531836]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 user -> user:[4026531837]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 uts -> uts:[4026531838]
        
        # 符号链接的作用：
        # 1. 确定某两个进程是否属于同一个namespace，如果两个进程属于同一个namespace，则符号链接的inode数字会是一样的
        # 2. 只要打开文件描述符，不需要进程存在也能保持namespace存在，例如
        touch /my/net	#新建一个文件
        mount --bind /proc/$$/ns/net /my/net
        # 如上所示，把/proc/PID/ns目录下挂载起来就能起到打开文件描述符的作用，而且这个network namespace会一直存在，直到/proc/self/ns/net被卸载
        ```

   3. 往`namespace`中添加进程，`setns`系统调用

      - `setns()`的定义如下

        ```c
        int setns(int fd,int nstype);
        /*
        * fd：进程待加入的namespace对应的文件描述符
        * nstype的作用检查fd的类型是否符合要求
        */
        ```

   4. `unshare`系统调用：帮助进程逃离`namespace`

      - `unshare()`的定义

        ```c
        int unshare(int flags);
        ```

      - `unshare`工作机制

        先通过指定`flags`参数创建相应的`namespace`,再把这个进程挪到新创建的`namespace`中

      - `Linux`中的`unshare`命令

        ```shell
        [root@docker01 ~]# unshare --help
        Usage:
         unshare [options] <program> [<argument>...]
         
        Run a program with some namespaces unshared from the parent.
        
        Options:
         -m, --mount               unshare mounts namespace
         -u, --uts                 unshare UTS namespace (hostname etc)
         -i, --ipc                 unshare System V IPC namespace
         -n, --net                 unshare network namespace
         -p, --pid                 unshare pid namespace
         -U, --user                unshare user namespace
         -f, --fork                fork before launching <program>
             --mount-proc[=<dir>]  mount proc filesystem first (implies --mount)
         -r, --map-root-user       map current user to root (implies --user)
             --propagation <slave|shared|private|unchanged>
                                   modify mount propagation in mount namespace
         -s, --setgroups allow|deny  control the setgroups syscall in user namespaces
        
         -h, --help     display this help and exit
        ```

   

二、`veth pair`详解

1. `veth pair`概念及基本操作

   - 概念：`veth`是虚拟以太网卡`(Virtual Ethernet)`的缩写，`veth`设备总是成对的，因此我们称之为`veth pair`。`veth pair`一端发送的数据会在另一端接收，非常像`Linux`的双向管道

   - 常用操作:

     ```shell
     # 创建veth pair
     ip link add veth0 type veth peer name veth1
     # 查看veth设备
     ip link list
     # 将设备状态设置为up
     ip link set dev veth0 up
     ip link set dev veth1 up
     # 为设备配置ip地址
     ifconfig veth0 192.168.1.1/24
     # 将veth设备放置到名称空间中
     ip link set veth1 netns netns1
     ```

2. 容器与`host veth pair`的关系

   - 查看容器中网卡与主机`veth`成对关系的方法
     - 对比容器内`eth0`网卡` cat /sys/class/net/eth0/iflink`的值，遍历主机上`/sys/class/net`下面的全部目录，招待与容器中`iflink`值相同的`veth`的名字

三、`Linux Bridge`

1. 概念

   - 网桥是二层网络设备，两个端口分别有一条独立的交换信道，不共享一条背板总线，可隔离冲突域
   - 连个`network namespace`之间可以通过`veth pair`实现，但多个`network namespace`相连就需要`bridge`
   - `Linux bridge`有多个端口，数据可以从任何端口进来，进来之后从哪个端口出去取决于目的`MAC`,原理和物理交换机差不多

2. `Linux bridge`基本操作

   ```shell
   # 创建一个网桥br0
   ip link add name br0 type bridge
   ip link set br0 up
   # 创建一对veth pair设备，并配置ip地址
   # 将veth0放到br0上
   ip link set dev veth0 master br0
   ```

3. `Linux bridge`在网络虚拟化中的应用

   - 虚拟机

     虚拟机通过`tun/tap`设备，将虚拟机内的网卡与`br0`连接起来，虚拟机发出去的数据包先到达`br0`，然后有`br0`交给`eth0`发送出去，数据包都不需要经过`host`机器的协议栈，效率高

   - 容器

     容器中使用的`veth pair`设备，而虚拟机使用的是`tun/tap`设备，在虚拟机场景下，虚拟机一般会和主机在同一网段，而在容器场景下，容器和物理网络不再同一个网段内

4. 网络接口的混杂模式

   - 概念：

     - 混杂模式，`(Promiscuous mode)`，简称`Promisc mode`，俗称"监听模式"，通常被网络管理员用来诊断网络问题

     - 混杂模式是指一个网卡会把它接收的所有流量都交给`cpu`，而不是只把它像转交的部分交给`cpu`.

       ```shell
       # 启用网卡的混杂模式
       [root@docker01 ~]# ifconfig ens33 promisc
       [root@docker01 ~]# ifconfig ens33
       ens33: flags=4419<UP,BROADCAST,RUNNING,PROMISC,MULTICAST>  mtu 1500
       # 使网卡退出混杂模式
       [root@docker01 ~]# ifconfig ens33 -promisc
       # 将网络设备加入Linux bridge后，会自动进入混杂模式
       [root@docker01 ~]# dmesg |grep promiscuous
       [ 2534.759461] device veth0 entered promiscuous mode
       [ 4241.507234] device ens33 entered promiscuous mode
       ```

5. `tun/tap`设备

   - 概念：
     - 从`Linux`文件系统角度来看，它是用户可以用文件句柄操作的字符设备
     - 从网络虚拟化角度看，它是虚拟网卡，一端连接着网络协议栈，一端连接着用户态程序
     - 从网络协议栈的角度看，`tun/tap`设备这类虚拟网卡与物理网卡并无区别，只是对`tun/tap`设备而言，它与物理网卡的不同表现在它的数据源不是物理链路，而是来自***用户态***
     - 普通的网卡是通过网线来收发数据包的话，而 ***`tun/tap`*** 设备比较特殊，它通过一个文件收发数据包

   1. `tun(tunnel隧道)`设备：
      - 工作模式：
        - `tunX`和`eth0`在逻辑上是等价的，`tunX`这个接口是系统通过软件模拟出来的
        - 网卡接口`tunX`所代表的虚拟网卡通过文件`/dev/tunX`与我们的应用程序相连，应用程序每次通过`write`之类的系统调用将数据写入该文件，这些数据会以网络层数据包的形式，通过该虚拟网卡，经由网络接口`tunX`传递给网络协议栈，同时程序也可通过`read`之类的系统调用，经由文件`/dev/tunX`读取到协议栈向`tunX`穿都的所有数据包
        - 协议栈可以像操纵普通网卡一样来操纵 `tunX` 所代表的虚拟网卡。比如说，给 `tunX` 设定 `IP` 地址，设置路由
   2. `tap`设备
      - `tun`设备是一个三层设备，它只模拟到了`IP`层，即网络层我们可以通过`/dev/tunX`文件收发`IP`层数据包，它无法与物理网卡做`bridge`，但是可以通过三层交换(如`ip_forward`)与物理网卡连通，可以使用`ifconfig`之类的命令给设备设定`IP`地址
      - `tap`设备是一个二层设备，它比`tun`更加深入，通过`/dev/tapX`文件可以手法`MAC`层数据包，即数据链路层，拥有`MAC`层功能，可以与物理网卡做`bridge`，支持`MAC`层广播，同样的，我们可以通过`ifconfig`之类的命令给设备设定`IP`地址，我们也可以给它设定`MAC`地址

6. `iptables`

   1. `netfilter`：作为一个通用的，抽象的框架，提供一整套`hook`函数的管理机制

      - `IP`层的5个钩子点的位置，对应于`iptables`五条链，分别是`PREROUTING,POSTROUTING,INPUT,OUTPUT,FORWARD`
      - `netfilter`是`Linux`内核网络模块的一个经典框架

   2. `iptables`之`table,chain,rule`

      - `iptables`是用户空间的一个程序，通过`netlink`和内核的`netfilter`框架打交道，负责往钩子上配置回调函数

      - `iptables`中的5条链

        - `INPUT`：一般用于处理输入本地进程的数据包
        - `OUTPUT`：一般用于处理本地进程的输出数据包
        - `FORWARD`：一般用于处理转发到其他机器或其它`network namespace`的数据包
        - `PREROUTING`：可以在此处进行`DNAT`
        - `POSTROUTING`：可以在此处进行`SNAT`

      - `iptables`中的5张表

        - `filter`：用于控制到达某条链上的数据包是否继续放行，直接丢弃(`drop`)，或拒绝(`reject`)
        - `nat`：用于修改数据包的源和目的地址
        - `mangle`：用于修改数据包的`IP`头信息
        - `raw`：`iptables`是有状态的，即`iptables`对数据包有链接追踪机制，而`raw`是去除这种机制的
        - `security`：最不常用的表，用于在数据包上应用`SELinux`

        这五张表的优先级从高到低是：`raw,mangle,nat,filter,security`

      - `iptables`的规则：

        - 匹配条件：协议类型，源`IP`，目标`IP`，源端口，目标端口，连接状态等
        - 动作：`DROP(丢弃),REJECT(拒绝),QUEUE(放入用户空间队列),RETURN(),ACCEPT,JUMP(跳转到其它用户自定义链继续执行)`

   3. `iptables`常规用法：

      1. 查看所有`iptables`规则

         ```shell
         # 列出iptables的所有规则
         iptables -L -n   
         # 默认输出的filter表中的规则，如果想要看nat表中的规则，则：
         iptables -t nat -L -n
         # 一般情况下还可使用-v列出详细信息
         iptables -nvL
         ```

         - `iptables`的每条链下面的规则处理顺序是从上到下逐条遍历的，除非遇到`DEOP,RETURN,REJECT`这些动作

      2. 配置内置链的默认策略

         ```shell
         # 默认的不让进
         iptables --policy INPUT DROP
         # 默认的不允许转发
         iptables --policy FORWARD DROP
         # 默认的可以出去
         iptables --policy OUTPUT ACCEPT
         ```

      3. 配置防火墙规则策略

         - 默认策略是全通`ACCEPT`，则需要定义一些策略来封堵(黑名单)

         - 默认策略是全不同`DROP`，则需要定义一些策略来解封(白名单)

         - 配置示例：

           ```shell
           ## 1.配置允许SSH连接
           iptables -A INPUT -s 192.169.1.0/24 -p tcp --dport=22 -j ACCEPT
           # -A :以追加的方式增加这条规则
           # 允许来自192.169.1.0/24网段的包发送到本地tcp 22号端口
           # 也可通过iptables -I [chain] [number]将规则Insert到链的指定位置
           
           ## 2.阻止来自某个网段的所有的包
           iptables -A INPUT -s 10.0.0.0/24 -j DROP #阻止10.0.0.0/24网段的所有包
           iptables -A INPUT -s 10.0.0.6 -j DROP    #组织单个ip
           
           ## 3.封锁端口
           iptables -A INPUT -p tcp --dport 1234 -j DROP #阻止外部访问本地1234端口
           iptables -A OUTPUT -p tcp --dport 1234 -j DROP #阻止本地1234端口对外访问
           
           ## 4.端口转发
           iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080
           # 将从eth0口进来的目标端口是80的数据包重定向到8080端口
           
           ## 5.禁用ping
           iptables -A INPUT -p icmp -j DROP
           
           ## 6.删除规则
           iptables -F #清除当前所有规则
           iptables -t nat -F #清楚nat表的规则
           iptables -D INPUT -s 10.0.0.10 -j DROP #清除单条规则
           
           ## 7.自定义链
           iptables -N BAR
           iptables -X FOO # 删除空链
           ```

      4. `DNAT`
      
         ```shell
         iptables -t nat -A PREROUTING -d 1.2.3.4 -p tcp --dport 80 -j DNAT --to-destination 10.20.30.40:8080
         # 注意：当涉及转发的目的IP是外机时，需要确保启用ip forward,把Linux当交换机用
         echo 1 >/proc/sys/net/ipv4/ip_forward
         ```
      
      5. `SNAT`/网络地址欺骗
      
         ```shell
         # 修改数据包的源IP地址
         iptables -t nat -A POSTROUTING -s 192.168.1.2 -j SNAT --to-source 10.0.0.12
         
         # 网络地址伪装，其实就是一种特殊的源地址转换，报文从哪个网卡出就用该网卡的IP地址替换该报文的源地址
         iptables -t nat -A POSTROUTING -s 10.9.0.0/16 -j MASQUERADE
         # 如果要控制被替换的源地址，则需要使用-o eth0指定报文从eth0口出并使用eth0网口的IP地址做源地址伪装
         ```
      
      6. 保存与恢复
      
         ```shell
         # iptables规则做出的改变是临时的，重启机器后就会丢失
         iptables-save #持久化到本地
         iptables-save > iptables.bak  #重定向到文件
         iptables-restore < iptables.bak  # 还原iptables规则
         ```

7. `Linux`隧道：`ipip`