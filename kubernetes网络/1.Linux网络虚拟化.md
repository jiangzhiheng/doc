一、网络虚拟化基础：`namespace`

1. `Linux`的`namespace`：

   - 作用：隔离内核资源
   - 种类：
     - `Mount namespace`：文件系统挂载点
     - `UTS namespace`：主机名
     - `IPC namespace`：`POSIX`进程间通信消息队列
     - `PID namespace`：进程`PID`数字空间
     - `network namespace`：`IP`地址
     - `user namespace`：`user ID`
   - 特点：`Linux`的`namespace`给里面的进程造成了两个错觉：
     - 它是系统里唯一的进程
     - 它独享系统的所有资源
   - 默认情况下，`Linux`进程处在和宿主机相同的`namespace`,即初始的根`namespace`里，默认享有全局系统资源

2. `network namespace`

   - 作用：隔离`Linux`系统的设备，以及`IP`地址、端口、路由表、防火墙规则等资源，因此每个网络`namespace`中都有自己的网络设备（如`IP`地址、路由表，端口范围、`/proc/net`目录等）

3. `network namespace`的创建

   - 通过`Linux`的`ip`工具的`netns`子命令

     ```shell
     [root@docker01 ~]# ip netns help
     Usage: ip netns list
            ip netns add NAME
            ip netns set NAME NETNSID
            ip [-all] netns delete [NAME]
            ip netns identify [PID]
            ip netns pids NAME
            ip [-all] netns exec [NAME] cmd ...
            ip netns monitor
            ip netns list-id
     ```

     ```shell
     # 创建一个network namespace
     ip netns add netns1
     # 查看系统有哪些network namespace
     ip netns list
     # 进入namespace执行操作
     ip netns exec netns1 ip link list
     # 删除创建network namespace
     ip netns delete netns1
     
     # 当ip命令创建了一个network namespace时，系统会在/var/run/netns路径下自动生成一个挂载点，挂载点的作用一方面是对namespace的管理，另一方面是使namespace没有进程运行也能存在
     ```

4. 配置`network namespace`

   1. 启用`lo`接口，默认`down`

      ```shell
      # ip netns exec netns1 ip link set dev lo up
      # ip netns exec netns1 ping 127.0.0.1 
      PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
      64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.039 ms
      ```

   2. 创建`veth pair`

      ```shell
      # 创建veth pair
      ip link add veth0 type veth peer name veth1
      # 将veth1放到netns1 namespace中
      ip link set veth1 netns netns1
      
      [root@docker01 ~]# ip netns exec netns1 ip link list
      1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
          link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      5: veth1@if6: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
          link/ether fe:ce:e7:4b:9f:a3 brd ff:ff:ff:ff:ff:ff link-netnsid 0
      ```

   3. 配置`veth pair`

      ```shell
      # 给netns1中的veth1设置ip地址并up
      ip netns exec netns1 ifconfig veth1 10.1.1.1/24 up
      # 给veth pair的另一半(位于宿主机)设置ip地址
      ifconfig veth0 10.1.1.2/24 up
      ```

   4. 双向测试

      ```shell
      [root@docker01 ~]# ping 10.1.1.1
      64 bytes from 10.1.1.1: icmp_seq=2 ttl=64 time=0.094 ms
      [root@docker01 ~]# ip netns exec netns1 ping 10.1.1.2
      64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.201 ms
      ```

   5. 另外，不同`network namespace`之间的路由表和防火墙等也是隔离的

   6. `Tips`

      - 进程可以通过`Linux`系统调用`clone(),unshare()和setns`进入`network namespace`

      - 非`root`进程被分配到`network namespace`后只能访问和配置已经存在于该`network`的设备

      - `root`进程可以在`network namespace`里创建新的网络设备

      - `network namespace`里的`root`进程还能把本`network namespace`的虚拟网络设备分配到其它`network namespace`,这个路径可以从主机的根`network namespace`到用户自定义的`namespace`,反之亦可

      - 请看以下命令

        ```shell
        ip netns exec netns1 ip link set veth1 1
        
        # 以上命令的作用是进入netns1，将veth1 移动到PID为1(init进程)所在的network namespace
        # 所以这会造成一定的安全风险，对namespace的root用户而言，它们都可以把namespace里的虚拟网络设备移动到其它network namespace中，甚至包括主机根network namespace！！，如果需要屏蔽这一行为，则需要结合PID namespace和Mount namespace
        ```

5. `network namespace API`的使用

   `clone(),unshare(),和setns()`系统调用会使用`CLONE_NEW*`来区别要操作的`namespace`类型，`CLONE_NEW*`常量一共有6个，分别是`CLONE_NEWIPC,CLONE_NEWNS,CLONE_NEWNET,CLONE_NEWPID,CLONE_NEWUSER,CLONE_NEWUTS`

   1. 创建`namespace`：`clone`系统调用

   2. `/proc/PID/ns`目录：维持`namespace`存在

      - 每个`Linux`进程都拥有一个属于自己的`/proc/PID/ns`,这个目录下的每一个文件都代表了一个类型的`namespace`,这些文件提供了操作进程关联`namespace`的一种方式

        ```shell
        [root@docker01 ~]# ll /proc/1/ns/
        total 0
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 ipc -> ipc:[4026531839]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 mnt -> mnt:[4026531840]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 net -> net:[4026531956] # 代表network namespace
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 pid -> pid:[4026531836]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 user -> user:[4026531837]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 uts -> uts:[4026531838]
        
        # 符号链接的作用：
        # 1. 确定某两个进程是否属于同一个namespace，如果两个进程属于同一个namespace，则符号链接的inode数字会是一样的
        # 2. 只要打开文件描述符，不需要进程存在也能保持namespace存在，例如
        touch /my/net	#新建一个文件
        mount --bind /proc/$$/ns/net /my/net
        # 如上所示，把/proc/PID/ns目录下挂载起来就能起到打开文件描述符的作用，而且这个network namespace会一直存在，直到/proc/self/ns/net被卸载
        ```

   3. 往`namespace`中添加进程，`setns`系统调用

      - `setns()`的定义如下

        ```c
        int setns(int fd,int nstype);
        /*
        * fd：进程待加入的namespace对应的文件描述符
        * nstype的作用检查fd的类型是否符合要求
        */
        ```

   4. `unshare`系统调用：帮助进程逃离`namespace`

      - `unshare()`的定义

        ```c
        int unshare(int flags);
        ```

      - `unshare`工作机制

        先通过指定`flags`参数创建相应的`namespace`,再把这个进程挪到新创建的`namespace`中

      - `Linux`中的`unshare`命令

        ```shell
        [root@docker01 ~]# unshare --help
        Usage:
         unshare [options] <program> [<argument>...]
         
        Run a program with some namespaces unshared from the parent.
        
        Options:
         -m, --mount               unshare mounts namespace
         -u, --uts                 unshare UTS namespace (hostname etc)
         -i, --ipc                 unshare System V IPC namespace
         -n, --net                 unshare network namespace
         -p, --pid                 unshare pid namespace
         -U, --user                unshare user namespace
         -f, --fork                fork before launching <program>
             --mount-proc[=<dir>]  mount proc filesystem first (implies --mount)
         -r, --map-root-user       map current user to root (implies --user)
             --propagation <slave|shared|private|unchanged>
                                   modify mount propagation in mount namespace
         -s, --setgroups allow|deny  control the setgroups syscall in user namespaces
        
         -h, --help     display this help and exit
        ```

   

二、`veth pair`详解

1. `veth pair`概念及基本操作

   - 概念：`veth`是虚拟以太网卡`(Virtual Ethernet)`的缩写，`veth`设备总是成对的，因此我们称之为`veth pair`。`veth pair`一端发送的数据会在另一端接收，非常像`Linux`的双向管道

   - 常用操作:

     ```shell
     # 创建veth pair
     ip link add veth0 type veth peer name veth1
     # 查看veth设备
     ip link list
     # 将设备状态设置为up
     ip link set dev veth0 up
     ip link set dev veth1 up
     # 为设备配置ip地址
     ifconfig veth0 192.168.1.1/24
     # 将veth设备放置到名称空间中
     ip link set veth1 netns netns1
     ```

2. 容器与`host veth pair`的关系

   - 查看容器中网卡与主机`veth`成对关系的方法
     - 对比容器内`eth0`网卡` cat /sys/class/net/eth0/iflink`的值，遍历主机上`/sys/class/net`下面的全部目录，招待与容器中`iflink`值相同的`veth`的名字

三、`Linux Bridge`

1. 概念

   - 网桥是二层网络设备，两个端口分别有一条独立的交换信道，不共享一条背板总线，可隔离冲突域
   - 连个`network namespace`之间可以通过`veth pair`实现，但多个`network namespace`相连就需要`bridge`
   - `Linux bridge`有多个端口，数据可以从任何端口进来，进来之后从哪个端口出去取决于目的`MAC`,原理和物理交换机差不多

2. `Linux bridge`基本操作

   ```shell
   # 创建一个网桥br0
   ip link add name br0 type bridge
   ip link set br0 up
   # 创建一对veth pair设备，并配置ip地址
   # 将veth0放到br0上
   ip link set dev veth0 master br0
   ```

3. `Linux bridge`在网络虚拟化中的应用

   - 虚拟机

     虚拟机通过`tun/tap`设备，将虚拟机内的网卡与`br0`连接起来，虚拟机发出去的数据包先到达`br0`，然后有`br0`交给`eth0`发送出去，数据包都不需要经过`host`机器的协议栈，效率高

   - 容器

     容器中使用的`veth pair`设备，而虚拟机使用的是`tun/tap`设备，在虚拟机场景下，虚拟机一般会和主机在同一网段，而在容器场景下，容器和物理网络不再同一个网段内

4. 网络接口的混杂模式

   - 概念：

     - 混杂模式，`(Promiscuous mode)`，简称`Promisc mode`，俗称"监听模式"，通常被网络管理员用来诊断网络问题

     - 混杂模式是指一个网卡会把它接收的所有流量都交给`cpu`，而不是只把它像转交的部分交给`cpu`.

       ```shell
       # 启用网卡的混杂模式
       [root@docker01 ~]# ifconfig ens33 promisc
       [root@docker01 ~]# ifconfig ens33
       ens33: flags=4419<UP,BROADCAST,RUNNING,PROMISC,MULTICAST>  mtu 1500
       # 使网卡退出混杂模式
       [root@docker01 ~]# ifconfig ens33 -promisc
       # 将网络设备加入Linux bridge后，会自动进入混杂模式
       [root@docker01 ~]# dmesg |grep promiscuous
       [ 2534.759461] device veth0 entered promiscuous mode
       [ 4241.507234] device ens33 entered promiscuous mode
       ```

5. `tun/tap`设备

   

   