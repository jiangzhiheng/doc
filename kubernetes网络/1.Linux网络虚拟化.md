一、网络虚拟化基础：`namespace`

1. `Linux`的`namespace`：

   - 作用：隔离内核资源
   - 种类：
     - `Mount namespace`：文件系统挂载点
     - `UTS namespace`：主机名
     - `IPC namespace`：`POSIX`进程间通信消息队列
     - `PID namespace`：进程`PID`数字空间
     - `network namespace`：`IP`地址
     - `user namespace`：`user ID`
   - 特点：`Linux`的`namespace`给里面的进程造成了两个错觉：
     - 它是系统里唯一的进程
     - 它独享系统的所有资源
   - 默认情况下，`Linux`进程处在和宿主机相同的`namespace`,即初始的根`namespace`里，默认享有全局系统资源

2. `network namespace`

   - 作用：隔离`Linux`系统的设备，以及`IP`地址、端口、路由表、防火墙规则等资源，因此每个网络`namespace`中都有自己的网络设备（如`IP`地址、路由表，端口范围、`/proc/net`目录等）

3. `network namespace`的创建

   - 通过`Linux`的`ip`工具的`netns`子命令

     ```shell
     [root@docker01 ~]# ip netns help
     Usage: ip netns list
            ip netns add NAME
            ip netns set NAME NETNSID
            ip [-all] netns delete [NAME]
            ip netns identify [PID]
            ip netns pids NAME
            ip [-all] netns exec [NAME] cmd ...
            ip netns monitor
            ip netns list-id
     ```

     ```shell
     # 创建一个network namespace
     ip netns add netns1
     # 查看系统有哪些network namespace
     ip netns list
     # 进入namespace执行操作
     ip netns exec netns1 ip link list
     # 删除创建network namespace
     ip netns delete netns1
     
     # 当ip命令创建了一个network namespace时，系统会在/var/run/netns路径下自动生成一个挂载点，挂载点的作用一方面是对namespace的管理，另一方面是使namespace没有进程运行也能存在
     ```

4. 配置`network namespace`

   1. 启用`lo`接口，默认`down`

      ```shell
      # ip netns exec netns1 ip link set dev lo up
      # ip netns exec netns1 ping 127.0.0.1 
      PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
      64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.039 ms
      ```

   2. 创建`veth pair`

      ```shell
      # 创建veth pair
      ip link add veth0 type veth peer name veth1
      # 将veth1放到netns1 namespace中
      ip link set veth1 netns netns1
      
      [root@docker01 ~]# ip netns exec netns1 ip link list
      1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
          link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      5: veth1@if6: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
          link/ether fe:ce:e7:4b:9f:a3 brd ff:ff:ff:ff:ff:ff link-netnsid 0
      ```

   3. 配置`veth pair`

      ```shell
      # 给netns1中的veth1设置ip地址并up
      ip netns exec netns1 ifconfig veth1 10.1.1.1/24 up
      # 给veth pair的另一半(位于宿主机)设置ip地址
      ifconfig veth0 10.1.1.2/24 up
      ```

   4. 双向测试

      ```shell
      [root@docker01 ~]# ping 10.1.1.1
      64 bytes from 10.1.1.1: icmp_seq=2 ttl=64 time=0.094 ms
      [root@docker01 ~]# ip netns exec netns1 ping 10.1.1.2
      64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.201 ms
      ```

   5. 另外，不同`network namespace`之间的路由表和防火墙等也是隔离的

   6. `Tips`

      - 进程可以通过`Linux`系统调用`clone(),unshare()和setns`进入`network namespace`

      - 非`root`进程被分配到`network namespace`后只能访问和配置已经存在于该`network`的设备

      - `root`进程可以在`network namespace`里创建新的网络设备

      - `network namespace`里的`root`进程还能把本`network namespace`的虚拟网络设备分配到其它`network namespace`,这个路径可以从主机的根`network namespace`到用户自定义的`namespace`,反之亦可

      - 请看以下命令

        ```shell
        ip netns exec netns1 ip link set veth1 1
        
        # 以上命令的作用是进入netns1，将veth1 移动到PID为1(init进程)所在的network namespace
        # 所以这会造成一定的安全风险，对namespace的root用户而言，它们都可以把namespace里的虚拟网络设备移动到其它network namespace中，甚至包括主机根network namespace！！，如果需要屏蔽这一行为，则需要结合PID namespace和Mount namespace
        ```

5. `network namespace API`的使用

   `clone(),unshare(),和setns()`系统调用会使用`CLONE_NEW*`来区别要操作的`namespace`类型，`CLONE_NEW*`常量一共有6个，分别是`CLONE_NEWIPC,CLONE_NEWNS,CLONE_NEWNET,CLONE_NEWPID,CLONE_NEWUSER,CLONE_NEWUTS`

   1. 创建`namespace`：`clone`系统调用

   2. `/proc/PID/ns`目录：维持`namespace`存在

      - 每个`Linux`进程都拥有一个属于自己的`/proc/PID/ns`,这个目录下的每一个文件都代表了一个类型的`namespace`,这些文件提供了操作进程关联`namespace`的一种方式

        ```shell
        [root@docker01 ~]# ll /proc/1/ns/
        total 0
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 ipc -> ipc:[4026531839]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 mnt -> mnt:[4026531840]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 net -> net:[4026531956] # 代表network namespace
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 pid -> pid:[4026531836]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 user -> user:[4026531837]
        lrwxrwxrwx 1 root root 0 Mar  3 01:46 uts -> uts:[4026531838]
        
        # 符号链接的作用：
        # 1. 确定某两个进程是否属于同一个namespace，如果两个进程属于同一个namespace，则符号链接的inode数字会是一样的
        # 2. 只要打开文件描述符，不需要进程存在也能保持namespace存在，例如
        touch /my/net	#新建一个文件
        mount --bind /proc/$$/ns/net /my/net
        # 如上所示，把/proc/PID/ns目录下挂载起来就能起到打开文件描述符的作用，而且这个network namespace会一直存在，直到/proc/self/ns/net被卸载
        ```

   3. 往`namespace`中添加进程，`setns`系统调用

      - `setns()`的定义如下

        ```c
        int setns(int fd,int nstype);
        /*
        * fd：进程待加入的namespace对应的文件描述符
        * nstype的作用检查fd的类型是否符合要求
        */
        ```

   4. `unshare`系统调用：帮助进程逃离`namespace`

      - `unshare()`的定义

        ```c
        int unshare(int flags);
        ```

      - `unshare`工作机制

        先通过指定`flags`参数创建相应的`namespace`,再把这个进程挪到新创建的`namespace`中

      - `Linux`中的`unshare`命令

        ```shell
        [root@docker01 ~]# unshare --help
        Usage:
         unshare [options] <program> [<argument>...]
         
        Run a program with some namespaces unshared from the parent.
        
        Options:
         -m, --mount               unshare mounts namespace
         -u, --uts                 unshare UTS namespace (hostname etc)
         -i, --ipc                 unshare System V IPC namespace
         -n, --net                 unshare network namespace
         -p, --pid                 unshare pid namespace
         -U, --user                unshare user namespace
         -f, --fork                fork before launching <program>
             --mount-proc[=<dir>]  mount proc filesystem first (implies --mount)
         -r, --map-root-user       map current user to root (implies --user)
             --propagation <slave|shared|private|unchanged>
                                   modify mount propagation in mount namespace
         -s, --setgroups allow|deny  control the setgroups syscall in user namespaces
        
         -h, --help     display this help and exit
        ```

   

二、`veth pair`详解

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         