一、配置数据库

1. `settings.py`文件中默认`sqlite`数据库，更改为`mysql`数据库

   实例：

   ```python
   DATABASES = {
       'default': {
           'ENGINE': 'django.db.backends.mysql',
           'NAME': 'helloworld',
           'USER': 'root',
           'PASSWORD': '123456',
           'HOST': '192.168.1.129',
           'PORT': '3306',
       }
   }
   ```

2. `project`的`init.py`文件中添加代码如下

   ```python
   import pymysql
   pymysql.install_as_MySQLdb()
   ```

二、`ORM`

1. 随着项目越来越大，才用原生的`SQL`的方式在代码中就会出现大量的`SQL`，那么就会出现如下问题：

   - `SQL`语句重复利用率不高，越复杂的`SQL`条件就会越多，代码越长，就出现很多相近`SQL`
   - 很多`SQL`语句都是在业务逻辑中拼接出来的，如果有数据库需要更改，就要去修改这些逻辑，这会很容易漏掉对某些`SQL`语句的更改
   - 写原生`SQL`语句时，会忽略`WEB`安全问题，造成隐患

2. 什么是`ORM`

   通过`ORM`我们可以通过类的方式操作数据库，而不用再去写原生的`SQL`语句，通过把表映射成类，把行作为实例，字段作为属性，`ORM`在操作数据库时，最终还是会转换为操作数据库的原生`SQL`语句。

3. 使用`ORM`的优点

   - 易用性：使用`ORM`做数据库的开发，可以有效减少重复`SQL`语句的概率，写出来的模型更加直观清晰。
   - 性能损耗小：`ORM`转换成底层数据库操作指令
   - 设计灵活，可以轻松的写出复杂的`SQL`语句
   - 可移植性，封装了底层数据库的实现，支持多个关系型数据库引擎。

三、模型的字段和可选条件

1. 字段类型

   |      字段名称      |                           字段说明                           |                             参数                             |
   | :----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
   |    `AutoField`     | 一个根据实际`ID`自动增长的`IntegerFiled`，通常不指定，自动生成 |                                                              |
   |    `CharField`     |                      `varchar`类型字段                       |                 `max_length`存储值得最大长度                 |
   |    `TextFiled`     |                    `longtext`类型的长文本                    |                                                              |
   |   `IntegerField`   |                   `int`类型字段，存储整型                    |                                                              |
   |   `DecimalField`   |                     存储浮点型，更加精准                     |  `max_digits=None`位数长度，`devimal_place=None`小数的位数   |
   |    `FloatField`    |                         存储浮点类型                         |                                                              |
   |   `BooleanField`   |                         存储`Bool`值                         |                                                              |
   | `NullBooleanField` |                    存储`null/True/False`                     |                                                              |
   |    `DateField`     |                          `date`参数                          | `auto_now=False`如果对数据进行修改，则会自动保存修改的时间，`auto_now_add=False`会自动保存第一次保存数据的时间，**两个参数不能同时使用** |
   |    `TimeField`     |                          `time`字段                          |                           参数同上                           |
   |  `DateTimeField`   |                        `datatime`字段                        |                           参数同上                           |

2. 字段选项

   |   可选参数    |                        参数说明                        |
   | :-----------: | :----------------------------------------------------: |
   |    `null`     |        如果设置为`True`，则当前字段可以为`null`        |
   |    `blank`    | 如果设置为`True`，则当前字段可以为`null`(什么值都没有) |
   |  `db_column`  |       设置字段名称，不设置，字段默认名称为属性名       |
   |  `db_index`   |                        常规索引                        |
   |   `unique`    |                        唯一索引                        |
   | `primary_key` |                        主键索引                        |
   |   `default`   |                         默认值                         |


四、定义模型

1. 模型 属性 表之间的关系

   一个模型类对应数据库中的一张表，一个类属性对应表中的一个字段

2. 创建测试模型类

   `models.py`

   ```python
   from django.db import models
   
   # Create your models here.
   
   class Test(models.Model):
       char = models.CharField(max_length=28,default='默认值',db_index=True)
       text = models.TextField(null=True,blank=True)
       inter = models.IntegerField(db_column='inte')
       deci = models.DecimalField(max_digits=5,decimal_places=2)
       float = models.FloatField()
       bool = models.BooleanField()
       null = models.NullBooleanField()
       data = models.DateField(auto_now=True)
       time = models.TimeField(auto_now=True)
       datatime = models.DateTimeField(auto_now=True)
       
       def __str__(self):
           return self.char
   ```

   注意：

   - `blank=True`只能用在字符串的字段类型上，不能用在数字字段

3. 执行迁移到我们的数据库中

   `python manage.py makemigrations`

   `python manage.py migrate`

   注意：

   - 如果在执行创建迁移文件的时候，提醒没有模型文件改变，那么就将新建的模型在别的试图函数中执行导入，那么出现这个问题的原因是`django`没有检测到所写的模型
   - 默认的模型名称为应用名_类名

   表结构

   ```shell
   mysql> desc test;
   +----------+--------------+------+-----+---------+----------------+
   | Field    | Type         | Null | Key | Default | Extra          |
   +----------+--------------+------+-----+---------+----------------+
   | id       | int(11)      | NO   | PRI | NULL    | auto_increment |
   | char     | varchar(28)  | NO   | MUL | NULL    |                |
   | text     | longtext     | YES  |     | NULL    |                |
   | inte     | int(11)      | NO   |     | NULL    |                |
   | deci     | decimal(5,2) | NO   |     | NULL    |                |
   | float    | double       | NO   |     | NULL    |                |
   | bool     | tinyint(1)   | NO   |     | NULL    |                |
   | null     | tinyint(1)   | YES  |     | NULL    |                |
   | data     | date         | NO   |     | NULL    |                |
   | time     | time(6)      | NO   |     | NULL    |                |
   | datatime | datetime(6)  | NO   |     | NULL    |                |
   +----------+--------------+------+-----+---------+----------------+
   ```

4. 元选项

   在模型类中定义一个`Meta`类

   ```python
   from django.db import models
   
   # Create your models here.
   
   
   class Test(models.Model):
   	...
       class Meta:
           db_table = 'test' # 修改表名为test，默认表名为App_test
           ordering = ['id'] # 查询出来的数据按照id升序
           ordering = ['-id'] # 查询出来的数据按照id降序
   
   ```

   当对模型进行了修改，则需要再次进行第3步的迁移操作

五、测试数据库

1. 进入到`pythonshell`进行操作

   `python manage.py shell`

2. 添加数据

   ```python
   def insert(req):
       # 第一种添加数据的方式
       """
       t = Test()
       t.char = 'char'
       t.text = 'text'
       t.inter = 1
       t.deci = 1.234
       t.float = 1.11
       t.bool = True
       t.null = None
       t.save()
       """
       # 第二种在实例化的时候传递关键字参数
       t = Test(char ='char',text = 'text',inter = 1,deci= 1.222,float=1.23,bool=False,null=None)
       return HttpResponse('添加数据')
       t.save()
   ```

3. 查询数据

   ```python
   # 查询数据
   def select(req):
       # 查询主键为1的数据
       t = Test.objects.get(pk=1)
       print(t)
       # 根据属性获取出想要的数据
       print(t.char)
       print(t.float)
       print(t.deci)
       return HttpResponse('查询数据')
   ```

4. 修改数据

   ```python
   # 修改数据
   def update(req):
       # 修改主键为1的数据
       t = Test.objects.get(pk=1)
       t.char = 'martin'
       t.save()
       return HttpResponse('修改数据')
   ```

5. 删除数据

   ```python
   # 删除数据
   def delete(req):
       t = Test.objects.get(pk=2)
       t.delete()
       return HttpResponse('删除数据')
   ```

六、模型成员

1. 类属性

   1. `objects`

      是`Manager`类的一个对象，作用是与数据库进行交互

      当定义模型的时候，没有指定模型管理器，则`Django`会默认为当前模型类创建一个名为`objects`的管理器。

   2. 自定义模型管理器名称

      ```python
      from django.db import models
      # Create your models here.
      
      class Test(models.Model):
      	...
          # 自定义模型管理器名称
          testobj = models.Manager
      	...
      ```

      注意：

      当自定义模型管理器的名称为`testobj`时，则默认的`objects`模型管理器就会不存在

      在视图函数中使用：

      ```python
      # 查询数据
      def select(req):
          # 查询主键为1的数据
          t = Test.testobj.get(pk=1)
          # 根据属性获取出想要的数据
          print(t.char)
          print(t.float)
          print(t.deci)
          return HttpResponse('查询数据')
      ```

   3. 自定义模型管理器功能`Manage`类

      概述：

      模型管理器是`django`模型与数据库进行交互的接口，一个模型可以有多个模型管理器

      作用：

      - 向管理器类中添加额外的方法
      - 修改管理器返回的原始查询集
      - 重写`get_query_set`方法

   4. 

2. 