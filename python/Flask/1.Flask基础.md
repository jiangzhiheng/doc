### 一、`Flask`框架的两大核心

`Werkzeug`和`jinja2`

`Werkzeug`：实现路由调试和`web`服务器网关接口

`jinja2`：实现了模板

### 二、`Flask`入门使用

1. 安装

   `pip install flask`

2. 启动完整程序

   实例

   ```python
   from flask import Flask
   
   # 实例化flask类，传入必传参数__name__
   app = Flask(__name__)
   
   # 添加路由
   @app.route('/')
   def index():
       return 'Hello Flask'
   
   # 运行
   if __name__ == '__main__':
       app.run(port=5000)
   ```

   注意：默认监听5000端口

   访问：` http://127.0.0.1:5000/ `

3. 路由地址

   ```python
   # 添加路由
   @app.route('/')
   def index():
       return 'Hello Flask'
   ```

4. 启动参数

   |    参数    |                        说明                         |
   | :--------: | :-------------------------------------------------: |
   |  `debug`   | 是否开启调试模式，默认`False`，开启后会自动加载代码 |
   | `threaded` |             是否开启多线程，默认不开启              |
   |   `port`   |                  端口号，默认5000                   |
   |   `host`   |              指定主机，默认`127.0.0.1`              |

   `app.run(host='0.0.0.0',port=5001,debug=True,threaded=True)`

### 三、视图参数

1. 无参路由

   ```python
   @app.route('/')
   def index():
       return 'Hello Flask'
   ```

   

   ```python
   # 创建test路由
   @app.route('/test/')
   def test():
       return 'test router'
   ```

2. 带一个参数的路由地址

   ```python
   # 带一个参数的路由地址
   # 访问： 127.0.0.1:5000/arg/martin/
   @app.route('/arg/<name>/')
   def arg(name):
       return '你好 '+ name
   ```

3. 带多个参数的路由地址

   ```python
   # 带多个参数的路由地址
   # 访问：http://127.0.0.1:5000/args/martin/19/
   # 访问：http://127.0.0.1:5000/args/martin_19/
   @app.route('/args/<name>/<age>/')
   @app.route('/args/<name>_<age>/')
   def args1(name,age):
       return 'name: {}， age: {}'.format(name,age)
   ```

4. 传参类型的限定

   ```python
      # 限定参数类型
      # 默认参数类型为字符串，可以通过int/float/path/string进行类型限定
      # @app.route('/test/<arg>/')
      # @app.route('/test/<int:arg>/')  # 限定为整型，否则失败
      # @app.route('/test/<float:arg>/')
      # @app.route('/test/<string:arg>/')   
      @app.route('/test/<path:arg>/')  # a/b/c/  会把/认为是参数的一部分
      def test(arg):
          print(type(arg))
          print(arg)
          return '测试路由地址传参的类型'
   ```

    注意：

      - 路由地址和视图函数可以不重名
      - `return` + 字符串的内容，目前所写的这种形式只是为了简单测试，后期返回的都是渲染后的模板
      - 在定义路由地址的时候，如果结尾没有添加`/`作为结尾，那么在访问的时候也不能加`/`，否则404。
      - 在定义路由地址的时候，如果结尾有`/`，在访问的时候，路由地址可以有`/`也可以没有，所以创建路由地址的时候建议都加`/`作为路由地址的结尾。
      - 参数的写法为 <参数名称>
      - 一个视图函数可以有多个路由地址
      - 一个视图函数传递多个参数 使用路由地址的分隔符`/`进行分隔 或使用`_`进行拼接。
      - 路由地址传递参数默认类型为字符串，可以通过`int/float/path/string`进行类型限定
      - 参数的限定格式为：`<参数类型限定符：参数名称>`


### 四、重定向`redirect`

1. 作用：

   可以通过访问的地址跳转到另外一个地址或视图函数

2. 导入：

   `from flask import redirect.url_for`

3. `redirect`使用实例：

   作用：通过给定的理由地址进行跳转访问

   ```python
   from flask import Flask
   from flask import redirect
   
   app = Flask(__name__)
   
   # 添加首页试图
   @app.route('/')
   def index():
       return 'Hello Flask'
   
   # 带参的视图函数
   @app.route('/args/<name>/<age>/')
   def args(name,age):
       return '我叫 ： {}, 我今年 {} 岁'.format(name,age)
   
   # 测试redirect
   # 无参视图函数的跳转
   @app.route('/test_redirect')
   def test_redirect():
       # return '测试重定向的视图函数'
       # 重定向到首页
       # return redirect('/')
       # 重定向到带参数的视图函数
       return redirect('/args/martin/18/',)
   
   if __name__ == '__main__':
       app.run(port=5001,debug=True)
   ```

   注意：

   - `redirect`跳转其实就是将你在浏览器访问的那个路由地址5000后面的粘贴过来就可以了，如果存在参数的位置，替换成参数即可。
   - 如果重定向的路由地址发生了改变，则重定向跳转失败（重定向的地址是写死的，不是动态生成的）

4. `url_for`使用实例

   作用：可以通过视图函数名称动态生成路由地址。

   ```python
   # url_for的使用
   @app.route('/test_url_for/')
   def test_url_for():
       # return '测试动态生成路由地址'
       # 测试无参路由地址
       # return url_for('index')
       # 测试带参的路由地址的构造
       return url_for('args',name='martin',age=18)
   ```

5. 组合使用

   ```python
   # redirect 和url_for的组合使用
   @app.route('/redirect_url_for/')
   def redirect_url_for():
       # return redirect(url_for('index'))
       return redirect(url_for('args',name='martin',age=18))
   ```

### 五、`abort`中止

1. 作用：

   如果在视图函数处理过程中，出现了异常错误，可以使用`abort`函数立即进行视图函数的中止

2. 传参：

   `abort`函数的传参为`http`标准的状态码，如404/500 返回状态码对应的信息，如果传递的参数为`http`标准中不存在，则无任何实际意义，类似于`raise`

3. 导入：

   `from flask import abort`

   实例：

   ```python
   @app.route('/test_abort/')
   def test_abort():
       # abort(404)
       abort(500)
       return 'test_abort'
   ```

   注意：

   - 如果给定的状态码不存在，则抛出`flask`异常的错误信息
   - `abort`和`raise`都会正常执行上面的代码，下面的代码不再执行

   注意：

   - 不光可以捕获人为输出的状态码，还可以捕获系统抛出的

   - 捕获抛出的状态码，可以自定义异常页面，如果想捕获多个，多写几个捕获的装饰器即可，示例如下：

   ```python
   # 捕获状态码（1.系统自己抛出，2.人为抛出）
   # 参数为要捕获的状态码
   @app.errorhandler(404)
   def page_not_found(e):
       # return '错误为：{}'.format(e)
       # 渲染模板
       return render_template('page_not_found.html')
   ```

### 六、请求`request`

1. 作用：

   获取请求者所携带的数据

   概述：浏览器发送到服务器的所有请求被`flask`接收以后，创建出`request`请求对象，被用在视图函数中，捕获请求的数据。

2. 使用：

   导入：

   `from flask import request`

   **`request`请求对象的属性**

   1. `url`：获取完整的请求`URL`
   2. `base_url`：去掉`get`参数的`URL`
   3. `host_url`：只有主机，端口号的`URL`
   4. `host`：返回主机和端口
   5. `path`：请求的路由地址
   6. `method`：请求的方法的类型
   7. `remote_add`：请求客户端的`IP`地址
   8. `args`：获取`get`传参
   9. `form`：获取`form`表单`post`方法请求的数据
   10. `files`：文件上传
   11. `headers`：存储所有请求头信息
   12. `cookies`：获取存储的`cookie`信息
   13. `json`：获取传递过来的`json`信息

   请求地址：`http://127.0.0.1:5000/test_request/?name=martin&age=19`

   实例：

   ```python
   from flask import Flask,request
   
   app = Flask(__name__)
   
   
   @app.route('/')
   def index():
       return 'index'
   
   
   @app.route('/test_request/')
   def test_request():
       # print(request.url)
       # print(request.base_url)
       # print(request.host_url)
       # print(request.host)
       # print(request.path)
       # print(request.method)
       print(request.remote_addr)
       print(request.args['name'])
       print(request.args['age'])
       # 建议使用get获取参数值
       print(request.args.get('xxx'))
       print(request.headers)
       print(request.headers.get('User-Agent'))
       return 'test_request'
   
   
   if __name__ == '__main__':
       app.run(debug=True)
   ```

   如果获取`get`传递的多个参数，可以使用如下代码实现：

   ```python
   # http://127.0.0.1:5000/test_request/?name=martin&name=19
   print(request.args.getlist('name'))
   print(request.args.getlist('name')[0])
   print(request.args.getlist('name')[1])
   ```

### 七、路由响应`response`

请求对象是框架创建的，响应对象是由我们程序员创建的

1. 一个简单的响应

   ```python
   # 构造一个简单的响应（携带状态码）
   @app.route('/')
   def index():
       return 'index',404
   ```

2. 通过`make_response`

   导入：

   `from flask import make_response`

   ```python
   @app.route('/make_responst/')
   def test_make_response():
       res = make_response('我是make_response构造的响应')
       return res
   ```

### 八、会话控制`cookie`与`session`

1. 概述

   我们的协议为`http`，无状态协议，每一次的请求都是新的请求，所以通过`cookie`和`session`作为一个连续回话请求的状态的保持。

2. 